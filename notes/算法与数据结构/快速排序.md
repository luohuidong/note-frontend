快排是非常高效的排序算法，其时间复杂度为 $O(n\log(n))$。

快排运用到分治的思想：

1. 找基准值（pivot）
2. 进行分区。将元素分为小于基准值、等于基准值、大于基准值三个数组。
3. 对小于、大于基准值的数组进行排序

下图为一个快排的简单例子：

![Pasted image 20240331190622](https://cdn.luohuidong.cn/Pasted%20image%2020240331190622.png)

## 基线条件

对于排序算法来说，最简单的数据就是根本不需要排序的数组：

- 空数组
- 只包含一个元素的数组

因此快排的基线条件是数组为空或只包含一个元素。因此上图中数组到元素长度为1的时候就终止分区，并且等待合并。

## 分区

分区其实就是找出比基准值小以及比基准值大的元素。虽然前面的例子中以第一个元素作为基准值，但其实基准值是可以取任意位置，下面则是取不同位置的元素作为基准值的分区情况：




![Pasted image 20240331195654](https://cdn.luohuidong.cn/Pasted%20image%2020240331195654.png)

## 实现

```ts
type CompareFunction<T> = (a: T, b: T) => number;

function quickSort<T>(array: T[], compareFn: CompareFunction<T>): T[] {
  if (array.length <= 1) {
    return array;
  }

  const pivotIndex = Math.floor(Math.random() * array.length);
  const pivot = array[pivotIndex];
  const equal: T[] = [];
  const lessThan: T[] = [];
  const right: T[] = [];

  array.forEach((item) => {
    if (compareFn(item, pivot) < 0) {
      lessThan.push(item);
    } else if (compareFn(item, pivot) > 0) {
      right.push(item);
    } else {
      equal.push(item);
    }
  });

  return quickSort(lessThan, compareFn).concat(equal, quickSort(right, compareFn));
}
```

上面的代码中，`pivotIndex` 通过随机数生成这个是特意这么做的，这主要是避免快排时间复杂度退化到 $O(n^{2})$ 的情况。

现在假设总是将第一个元素用作基准值，且要处理的数组是有序的。由于快排不检查输入数组是否有序，因此它依然尝试对其进行排序：

![Pasted image 20240331213805](https://cdn.luohuidong.cn/Pasted%20image%2020240331213805.png)

由于数组并没有被分成两半，其中一个数组始终为空，因此导致调用栈非常长。如果有8个数则调用栈高度则为8。

现在回到为什么基准值的索引是随机值而不是其他数值的问题上。假设我们不是随机值，而是选取中间元素，那么我完全可以针对这个算法设计一个中间值是最小值的数组，那这个时候快排的时间复杂度又退化到 $O(n^{2})$ 了。而虽然使用随机数也有可能选中最小值，但是每次递归都选中最小值的概率为 $\frac{1}{n!}$。这个概率在数据量比较大的情况下是非常小的。

## 参考资料

- [算法图解-第4章-快速排序](https://www.ituring.com.cn/book/tupubarticle/13077?bookID=1864&type=tubook&subject=%E7%AC%AC%204%20%E7%AB%A0%E3%80%80%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)